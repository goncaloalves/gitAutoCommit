# -*- coding: utf-8 -*-
"""
@author: goalves
"""

import os
import argparse
import sys
from subprocess import CalledProcessError, check_output
import urllib.request, urllib.error
import logging
from datetime import datetime

def run(command, **kw):
    try:
        output=check_output(command, **kw)
    except CalledProcessError:
        return []
    return output.decode().splitlines()

def status_git(path):
    lines=run(('git', 'status', '-s', '-b'), cwd=path)
    return [l for l in lines
    if not l.startswith('?') and (not l.startswith('##')) or ('ahead' in l)]

def walk(path, verbose):
    dirs=[]
    for dirpath, dirnames, filenames in os.walk(path):
        for dirname in dirnames:
            if dirname=='.git':
                if len(status_git(dirpath))>0:
                    dirs.append(dirpath)
                    if verbose: print('Found Git repository with uncommitted changes in {}'.format(dirpath))
    return dirs

def getNewCommitMessage(url):
    with urllib.request.urlopen(url) as response:
        commitMessage=response.read().decode('utf-8')
    return commitMessage
    
def gitAddAll(path, verbose):
    result=run(('git', 'add', '.'), cwd=path)
    if verbose: printGitMessage(result)
    
def gitCommit(path, message, verbose):
    result=run(('git', 'commit', '-m', message), cwd=path)
    if verbose: printGitMessage(result)
        
def gitPush(path, verbose):
    result=run(('git', 'push'), cwd=path)
    if verbose: printGitMessage(result)
        
def printGitMessage(genMessage):
    logger.debug(genMessage) 
    message=''.join(list(genMessage))
    if len(message)>1:
        print(message)
        
def setLogging(level):
    level=level.upper()
    if level=='CRITICAL':
        level = logging.CRITICAL
    elif level=='ERROR':
        level = logging.ERROR
    if level=='WARNING':
        level = logging.DEBUG
    if level=='INFO':
        level = logging.DEBUG
    else:
        level = logging.DEBUG
        
    logger =logging.getLogger()
    logger.setLevel(level)
    
    formatter=logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    fh=logging.FileHandler('AutoCommit.log')
    fh.setFormatter(formatter)
    fh.setLevel(level)
    logger.addHandler(fh)
    
    ch=logging.StreamHandler()
    ch.setLevel(level)    
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    
    return logger
       
def main():
    
    parser = argparse.ArgumentParser(description='Find and Auto Commit Git Repositories')
    parser.add_argument('DIR', default='/', help='Directory to be scanned')
    parser.add_argument('-v', dest='verbose', action="store_true", default=False, help='Turn Verbose On')
    parser.add_argument('-u', dest='url', default='http://whatthecommit.com/index.txt', help='URL with the commit messages')
    parser.add_argument('-c', dest='commit', action="store_true", default=False, help='Commit and Push Changes')
    parser.add_argument('-l', dest='logLevel', default='DEBUG', help='Logging Level (CRITICAL, ERROR, WARNING, INFO, DEBUG (default))')
    args= parser.parse_args()

    scriptMessage='Commit message generated by gitAutoCommit Script at {}'.format(datetime.now())

    global logger
    logger=setLogging(args.logLevel)
    
    try:
        message=getNewCommitMessage(args.url)
    except urllib.error.URLError:
        message=scriptMessage
    else:
        message=message + ' -- ' + scriptMessage

    path=os.path.abspath(args.DIR)

    print('Directory to be searched: ' + path)

    if args.verbose: 
        print('Commit Message to be used: ' + message)
        print()

    if not os.path.isdir(path):
        sys.stderr.write('{} is not a directory'.format(args.DIR))
    
    repos=walk(path, args.verbose)

    if args.commit:
        for repo in repos:
            gitAddAll(repo, args.verbose)
            gitCommit(repo, message, args.verbose)
            gitPush(repo, args.verbose)

if __name__=='__main__':
    main()